REQUIREMENTS {{{

User defined expression grammar (CFG?)
Read and store expressions from the command line.
Verify correctness of expressions.
Rewrite using user defined rewrite rules.


}}}

CONSTRAINTS {{{

All expressions are bracketed.

}}}

EXAMPLE SESSION {{{

define a grammar as a CFG
Different types of terminal symbols
Use whitespace as seperators

e.g.

op + - * / ^
var a b c d
exp (var) | (op exp exp)

The brackets around var allow for easy identification of exps.
Maybe remove these in future.

define rewrite rules

e.g.

com (+ exp1 exp2)            -> (+ exp2 exp1)
ass (* (* exp1 exp2) exp3)   -> (* exp1 (* exp2 exp3))


}}}

IMPLEMENTATION? {{{

LIST REPRESENTATION (WRONG) {{{

Generate a list of subexpressions
e.g. on reading the input expression
(+ (- a (* (+ c d) e)) (/ f g))

Doing this in the obvious way gives a list such as
e0 = (op e1 e2)
e1 = (op e3 e4)
...
The ass rule in the previous section could be split into two seperate matches.
First matching the outer (* e0 e3) then the inner e0=(* e1 e2)

This is essentially a list of nodes in the tree. i.e. a tree!

Is this better than my expr struct in the initial Go implementation?
}}}

Use of a parse tree decouples the internal representation from the grammar.


}}}

EXTRAS {{{

Allow terminal symbols to be defined using regexes.
var [a-zA-Z]

remove brackets from var

pretty printing


}}}

PLAN {{{

save current expression
input and name rules
apply rules to expression or subexpression

}}}

REWRITE RULES {{{

1          2
(a * b) -> (b * a)

To carry out the rule on an expr e.
* Check that 1 matches e.
* Associate the subexpr e.l and e.r with a and b.
* Construct 2
* Replace b with a copy of e.r and a with a coply of e.l.

//Defines the relationship between 1 and 2
func relate(1 expr, 2 expr) r rule

//Checks that the rule can be applied to e. i.e. 1 and e match
func fits(e expr, r rule) bool

//Outputs an expr with the form of 2 but with e.l, e.r inplace of a, b.
func apply(r rule, e expr) f expr


}}}
