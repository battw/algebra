package main

import (
	"bufio"
	"fmt"
	"github.com/llo-oll/algebra/expr"
	"github.com/llo-oll/algebra/toknify"
	"github.com/llo-oll/algebra/util"
	"os"
	"strconv"
)

type environ struct {
	expmap map[string]*expr.Expr
}

func newenviron() *environ {
	expmap := make(map[string]*expr.Expr)
	env := &environ{expmap}
	return env
}

func main() {
	engin, engout := eng()
	repl(engin, engout)
}

func repl(engin chan<- string, engout <-chan string) {
	bio := bufio.NewReader(os.Stdin)
	for {
		//read
		line, _ := bio.ReadString('\n')
		//execute
		engin <- line
		//print
		str := <-engout
		if len(str) > 0 {
			fmt.Println(str)
		}
	}
}

//eng is the algebra engine.
func eng() (chan<- string, <-chan string) {
	engin := make(chan string)
	engout := make(chan string)
	env := newenviron()
	go func() {
		for instr := range engin {
			engout <- handle(instr, env)
		}
	}()
	return engin, engout
}

func handle(input string, env *environ) string {
	runech := util.Runechan(input)
	tokch := toknify.Tokenise(runech)
	cmdtok := <-tokch
	switch cmdtok.Str {
	case "d", "dummy":
		return dummy()
	case "e", "expr":
		return exprdef(tokch, env)
	case "p", "print":
		return printexp(tokch, env)
	case "pv", "printvars":
		return printvars(tokch, env)
	case "r", "rule":
		return ruledef(tokch, env)
	case "a", "apply":
		return applyrule(tokch, env)
	case "s", "sub":
		return subexpr(tokch, env)
	case "sbs":
		return substitute(tokch, env)
	case "":
		return ""
	default:
		return cmdtok.Str + " is not a command"
	}
}


func typeerr(tok toknify.Tokn, should toknify.Toktyp) string {
	errmsg := ""
	if tok.Typ == toknify.NIL {
		errmsg += "Missing argument should be of type " + should.String()
	} else {
		errmsg += tok.Str + " is of type " + tok.Typ.String() +
			", should be of type " + should.String()
	}
	return errmsg
}

//TODO move this to tests.
func dummy(tokch <-chan toknify.Tokn) string {
	num := toknify.INT
	name := toknify.NAME
	exp := toknify.EXPR
	// nul := toknify.NIL
	// err := toknify.ERR
	sig0 := []toknify.Toktyp{name, name, exp}
	sig1 := []toknify.Toktyp{name, num, name, exp}
	sig2 := []toknify.Toktyp{name}
	sigs := [][]toknify.Toktyp{sig0, sig1, sig2}

	tokch := util.Runechan("barry harry (+ a b)")
	toks, sigi, err := paramcheck(sigs, tokch)
	return "DUM"
}

//paramcheck takes lists of correct token types, and checks them against those coming out of the
//channel. If they are correct, it returns a list containing them, an int giving the index of the
//matched param list.
func paramcheck(
	desired [][]toknify.Toktyp, tokch <-chan toknify.Tokn) ([]toknify.Tokn, int, error) {
	
	for tok := range tokch {
		fmt.Printf("%v\n", tok)
	}

	return nil, 0, nil
}

func exprdef(tokch <-chan toknify.Tokn, env *environ) string {
	tok1 := <-tokch
	if tok1.Typ != toknify.NAME {
		return typeerr(tok1, toknify.NAME)
	}
	tok2 := <-tokch
	if tok2.Typ != toknify.EXPR {
		return typeerr(tok2, toknify.EXPR)
	}
	//parse the expression
	exp, err := expr.Translate(tok2.Str)
	if err != nil {
		return fmt.Sprintf("%s", err)
	}
	//add to the environment
	env.expmap[tok1.Str] = exp
	return env.expmap[tok1.Str].String()
}

func printexp(tokch <-chan toknify.Tokn, env *environ) string {
	tok := <-tokch
	if tok.Typ != toknify.NAME {
		return typeerr(tok, toknify.NAME)
	}
	exp := env.expmap[tok.Str]
	if exp == nil {
		return "There is no expression named " + tok.Str
	}
	return exp.String()
}

func printvars(tokch <-chan toknify.Tokn, env *environ) string {
	str := ""
	for k, exp := range env.expmap {
		str += k + ": " + exp.String() + "\n"
	}
	return str[:len(str)-1]
}

func ruledef(tokch <-chan toknify.Tokn, env *environ) string {
	return "RULE"
}

func applyrule(tokch <-chan toknify.Tokn, env *environ) string {
	return "APPLY"
}

func subexpr(tokch <-chan toknify.Tokn, env *environ) string {
	tok1 := <-tokch
	if tok1.Typ != toknify.NAME {
		return typeerr(tok1, toknify.NAME)
	}
	tok2 := <-tokch
	if tok2.Typ != toknify.INT {
		return typeerr(tok2, toknify.INT)
	}
	exp := env.expmap[tok1.Str]
	if exp == nil {
		return "There is no expression named " + tok1.Str
	}
	subi, _ := strconv.Atoi(tok2.Str)
	return exp.Subexp(subi - 1).String() // -1 so counting from 1 up rather than 0
}

func substitute(tokch <-chan toknify.Tokn, env *environ) string {
	//TODO These if statement are repeated in all these functions.
	//Pull them out into a func untokn(toklist, desiredtoktyplist) (unlist, err)
	tok1 := <-tokch
	if tok1.Typ != toknify.NAME {
		return typeerr(tok1, toknify.NAME)
	}
	tok2 := <-tokch
	if tok2.Typ != toknify.INT {
		return typeerr(tok2, toknify.INT)
	}
	tok3 := <-tokch
	if tok3.Typ != toknify.NAME {
		return typeerr(tok3, toknify.NAME)
	}
	exp := env.expmap[tok1.Str]
	if exp == nil {
		return "There is no expression named " + tok1.Str
	}
	subi, _ := strconv.Atoi(tok2.Str)
	subexp := env.expmap[tok3.Str]
	if exp == nil {
		return "There is no expression named " + tok1.Str
	}

	return exp.Substitute(subi, subexp).String()
}
